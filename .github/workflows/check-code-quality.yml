name: Check code quality

# TODO determine when we launch CI automatically
# TODO handle CI on an orphan branch ?
# TODO don't fail on error
on:
  push:
    # branches:
    #   - 'feat**'

  pull_request:
    types: [opened, synchronize, reopened]

  workflow_dispatch:

env:
  SOURCES: src
  TESTS: tests

jobs:

  check-format:
    runs-on: ubuntu-latest
    name: Check format (black)
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/install-python
      - uses: psf/black@stable
        with:
          options: --check --verbose

  check-linting:
    runs-on: ubuntu-latest
    name: Check linting (ruff, flake8)
    steps:
      - uses: actions/checkout@v4      
      - uses: ./.github/actions/poetry-install      
      - run: poetry run ruff check --output-format=github . # used by pre-commit
        shell: bash
      - run: poetry run flake8 ${SOURCES} ${TESTS} --output-file .reports/flake8.txt # used by sonarqube
        shell: bash
      - uses: actions/upload-artifact@v3
        with:
          name: flake8          
          path: | # add a random file (.flake8) so .reports/ is saved as a dir
            .reports
            .flake8
          retention-days: 1

  check-typing:
    runs-on: ubuntu-latest
    name: Check typing (mypy)
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/poetry-install
      - run: poetry run mypy .
        shell: bash

  # TODO to be completed
  # check-vulnerabilities:
  #   runs-on: ubuntu-latest
  #   name: Check vulnerabilities (trivy)
  #   steps:
  #     - uses: actions/checkout@v4
  #     - uses: aquasecurity/trivy-action@master
  #       with:
  #         scan-type: 'fs'
  #         scan-ref: '.'

  run-unit-tests:
    runs-on: ubuntu-latest
    name: Run unit tests (pytest)
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/poetry-install

      - name: Run unit tests
        run: |
          set -x && poetry run pytest ${TESTS} \
            -m unit \
            --durations=0 \
            --error-for-skips \
            --cov=${SOURCES} \
            --cov-report=term \
            --cov-report=xml:.reports/coverage.xml \
            --junit-xml=.reports/TEST-pytests.xml \
        shell: bash

      - name: Code coverage summary
        uses: irongut/CodeCoverageSummary@v1.3.0
        with: # see https://github.com/marketplace/actions/code-coverage-summary#inputs
          filename: .reports/coverage.xml

      - name: Save reports as artifacts
        uses: actions/upload-artifact@v3
        with:
          name: pytest-unit
          path: |
            .coverage
            .reports
          retention-days: 1

  # TODO: what the integration tests should be, what is the difference from the unit tests ?
  # Should they be scheduled or run only when merging to the develop or main branch ?
  # Note that in the code below, the integration tests will not be counted for the code coverage.
  run-integration-tests:
    runs-on: ubuntu-latest
    name: Run integration tests (pytest)
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/poetry-install

      - name: Run integration tests
        run: |
          set -x && poetry run pytest ${TESTS} \
            -m integration \
            --durations=0 \
            --error-for-skips \
            --cov=${SOURCES} \
            --cov-report=term \
            --cov-report=xml:.reports/coverage-integration.xml \
        shell: bash

      - name: Save reports as artifacts
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: .reports/coverage-integration.xml

  generate-quality-report:
    runs-on: ubuntu-latest
    name: Quality report (sonarqube)
    steps:
      #- needs: [] # needs reports from previous jobs
      - uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          # Note: other options ?
          #   --debug
          #   -Dsonar.qualitygate.wait=true ? maybe handled by sonarsource/sonarqube-quality-gate-action ?
          #   -Dsonar.branch.name=${{ github.ref_name }} # Developer Edition or above is required
          args: >
            -Dsonar.projectKey=test-project
            -Dsonar.projectName=test-project
            -Dsonar.links.homepage=https://sonarqube.ops-csc.com/dashboard?id=test-project
      # If you wish to fail your job when the Quality Gate is red, uncomment the
      # following lines. This would typically be used to fail a deployment.
      - uses: sonarsource/sonarqube-quality-gate-action@master
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        continue-on-error: true # but still run next jobs
  


        # -Dsonar.projectBaseDir=.
        # -Dsonar.sources=${SOURCES}
        # -Dsonar.tests=${TESTS}
        # -Dsonar.exclusions=
        # -Dsonar.sourceEncoding=UTF-8
        # -Dsonar.language=py
        # -Dsonar.python.version=3.11


        # -Dsonar.python.flake8.reportPaths="linter.txt"
        # -Dsonar.python.bandit.reportPaths="vulnerability.json"
        # -Dsonar.python.xunit.reportPath="${REPORTS}/TEST-*.xml"
        # -Dsonar.python.coverage.reportPaths="${REPORTS}/coverage.xml"    